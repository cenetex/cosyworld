/**
 * Copyright (c) 2019-2025 Cenetex Inc.
 * Licensed under the MIT License.
 */

/**
 * @fileoverview NFT Metadata Service
 * Generates Base (ERC-721) and Solana NFT metadata manifests for avatars
 * @module src/services/nft/nftMetadataService
 */

export class NftMetadataService {
  constructor({ logger }) {
    this.logger = logger || console;
  }

  /**
   * Generate Base (ERC-721) metadata manifest for an avatar
   * Follows OpenSea metadata standard
   * @param {Object} avatar - Avatar object from database
   * @param {Object} options - Additional options
   * @param {string} options.imageUrl - URL to avatar image (ideally on Arweave)
   * @param {string} options.animationUrl - Optional URL to avatar animation/video
   * @returns {Object} ERC-721 compliant metadata
   */
  generateBaseMetadata(avatar, options = {}) {
    const { imageUrl, animationUrl } = options;
    
    const metadata = {
      name: avatar.name || 'CosyWorld Avatar',
      description: this._generateDescription(avatar),
      image: imageUrl || avatar.avatarImageUrl || avatar.generatedImageUrl,
      external_url: `https://cosyworld.ai/avatars/${avatar._id || avatar.id}`,
      attributes: this._generateAttributes(avatar),
    };

    // Add animation URL if provided (for animated avatars)
    if (animationUrl) {
      metadata.animation_url = animationUrl;
    }

    // Add additional ERC-721 properties
    if (avatar.personality) {
      metadata.background_color = this._getBackgroundColorFromPersonality(avatar.personality);
    }

    this.logger?.info?.(`[NftMetadataService] Generated Base metadata for avatar: ${avatar.name}`);
    return metadata;
  }

  /**
   * Generate Solana (Metaplex) metadata manifest for an avatar
   * Follows Metaplex Token Metadata Standard
   * @param {Object} avatar - Avatar object from database
   * @param {Object} options - Additional options
   * @param {string} options.imageUrl - URL to avatar image (ideally on Arweave)
   * @param {string} options.animationUrl - Optional URL to avatar animation/video
   * @param {number} options.sellerFeeBasisPoints - Royalty percentage (default: 500 = 5%)
   * @param {Array} options.creators - Array of creator objects with address and share
   * @returns {Object} Metaplex compliant metadata
   */
  generateSolanaMetadata(avatar, options = {}) {
    const {
      imageUrl,
      animationUrl,
      sellerFeeBasisPoints = 500, // 5% default royalty
      creators = []
    } = options;

    const metadata = {
      name: avatar.name || 'CosyWorld Avatar',
      symbol: 'COSY',
      description: this._generateDescription(avatar),
      image: imageUrl || avatar.avatarImageUrl || avatar.generatedImageUrl,
      external_url: `https://cosyworld.ai/avatars/${avatar._id || avatar.id}`,
      attributes: this._generateSolanaAttributes(avatar),
      properties: {
        files: [
          {
            uri: imageUrl || avatar.avatarImageUrl || avatar.generatedImageUrl,
            type: this._getImageMimeType(imageUrl || avatar.avatarImageUrl)
          }
        ],
        category: 'image',
        creators: creators.length > 0 ? creators : [
          {
            address: 'PLACEHOLDER_CREATOR_ADDRESS',
            share: 100
          }
        ]
      },
      seller_fee_basis_points: sellerFeeBasisPoints
    };

    // Add animation file if provided
    if (animationUrl) {
      metadata.animation_url = animationUrl;
      metadata.properties.files.push({
        uri: animationUrl,
        type: 'video/mp4'
      });
      metadata.properties.category = 'video';
    }

    this.logger?.info?.(`[NftMetadataService] Generated Solana metadata for avatar: ${avatar.name}`);
    return metadata;
  }

  /**
   * Generate a rich description for the avatar
   * @private
   */
  _generateDescription(avatar) {
    const parts = [];
    
    if (avatar.name) {
      parts.push(`Meet ${avatar.name}`);
    }
    
    if (avatar.personality) {
      parts.push(`a ${avatar.personality} character from CosyWorld`);
    }
    
    if (avatar.backstory) {
      parts.push(`\n\n${avatar.backstory}`);
    } else if (avatar.description) {
      parts.push(`\n\n${avatar.description}`);
    }
    
    if (avatar.race) {
      parts.push(`\n\nRace: ${avatar.race}`);
    }
    
    if (avatar.characterClass) {
      parts.push(`\nClass: ${avatar.characterClass}`);
    }

    parts.push('\n\nGenerated by AI in the CosyWorld metaverse.');
    
    return parts.join(' ');
  }

  /**
   * Generate OpenSea-compatible attributes
   * @private
   */
  _generateAttributes(avatar) {
    const attributes = [];

    // Core attributes
    if (avatar.race) {
      attributes.push({
        trait_type: 'Race',
        value: avatar.race
      });
    }

    if (avatar.characterClass) {
      attributes.push({
        trait_type: 'Class',
        value: avatar.characterClass
      });
    }

    if (avatar.personality) {
      attributes.push({
        trait_type: 'Personality',
        value: avatar.personality
      });
    }

    // Stats
    if (avatar.level) {
      attributes.push({
        trait_type: 'Level',
        value: avatar.level,
        display_type: 'number'
      });
    }

    if (avatar.health !== undefined) {
      attributes.push({
        trait_type: 'Health',
        value: avatar.health,
        display_type: 'number',
        max_value: 100
      });
    }

    if (avatar.attack !== undefined) {
      attributes.push({
        trait_type: 'Attack',
        value: avatar.attack,
        display_type: 'number'
      });
    }

    if (avatar.defense !== undefined) {
      attributes.push({
        trait_type: 'Defense',
        value: avatar.defense,
        display_type: 'number'
      });
    }

    // Guild affiliation
    if (avatar.guildId) {
      attributes.push({
        trait_type: 'Guild',
        value: avatar.guildId
      });
    }

    // Generation metadata
    if (avatar.createdAt) {
      attributes.push({
        trait_type: 'Born',
        value: new Date(avatar.createdAt).getFullYear(),
        display_type: 'date'
      });
    }

    return attributes;
  }

  /**
   * Generate Solana-style attributes
   * @private
   */
  _generateSolanaAttributes(avatar) {
    const attributes = [];

    if (avatar.race) {
      attributes.push({ trait_type: 'Race', value: avatar.race });
    }

    if (avatar.characterClass) {
      attributes.push({ trait_type: 'Class', value: avatar.characterClass });
    }

    if (avatar.personality) {
      attributes.push({ trait_type: 'Personality', value: avatar.personality });
    }

    if (avatar.level) {
      attributes.push({ trait_type: 'Level', value: avatar.level.toString() });
    }

    if (avatar.guildId) {
      attributes.push({ trait_type: 'Guild', value: avatar.guildId });
    }

    return attributes;
  }

  /**
   * Get background color based on personality
   * @private
   */
  _getBackgroundColorFromPersonality(personality) {
    const colors = {
      brave: 'FF4444',
      wise: '4444FF',
      mysterious: '6B46C1',
      cheerful: 'FFD700',
      cunning: '2F4F4F',
      noble: 'DAA520',
      fierce: 'DC143C',
      gentle: '98FB98'
    };

    const key = Object.keys(colors).find(k => 
      personality?.toLowerCase().includes(k)
    );

    return colors[key] || 'FFFFFF';
  }

  /**
   * Determine MIME type from URL
   * @private
   */
  _getImageMimeType(url) {
    if (!url) return 'image/png';
    
    if (url.endsWith('.png')) return 'image/png';
    if (url.endsWith('.jpg') || url.endsWith('.jpeg')) return 'image/jpeg';
    if (url.endsWith('.gif')) return 'image/gif';
    if (url.endsWith('.webp')) return 'image/webp';
    
    return 'image/png';
  }

  /**
   * Generate deployment manifest with both Base and Solana metadata
   * @param {Object} avatar - Avatar object
   * @param {Object} options - Deployment options
   * @returns {Object} Complete deployment manifest
   */
  generateDeploymentManifest(avatar, options = {}) {
    const manifest = {
      avatar: {
        id: avatar._id?.toString() || avatar.id,
        name: avatar.name,
        imageUrl: avatar.avatarImageUrl || avatar.generatedImageUrl
      },
      base: this.generateBaseMetadata(avatar, options),
      solana: this.generateSolanaMetadata(avatar, options),
      arweave: {
        uploaded: false,
        txId: null,
        url: null
      },
      generated: new Date().toISOString()
    };

    this.logger?.info?.(`[NftMetadataService] Generated deployment manifest for avatar: ${avatar.name}`);
    return manifest;
  }
}
