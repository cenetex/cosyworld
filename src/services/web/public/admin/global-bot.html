<!--
  Copyright (c) 2019-2024 Cenetex Inc.
  Licensed under the MIT License.
-->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Global Bot Management - Admin Dashboard</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet" />
  <link href="/css/admin-common.css" rel="stylesheet" />
  <style>
    .global-bot-container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }
    
    .section {
      background: white;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .section h2 {
      margin-top: 0;
      color: #333;
      border-bottom: 2px solid #667eea;
      padding-bottom: 10px;
    }
    
    .persona-info {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }
    
    .info-card {
      background: #f7fafc;
      padding: 15px;
      border-radius: 6px;
      border-left: 4px solid #667eea;
    }
    
    .info-card label {
      font-weight: bold;
      color: #4a5568;
      display: block;
      margin-bottom: 5px;
    }
    
    .info-card value {
      color: #2d3748;
      font-size: 1.1em;
    }
    
    textarea {
      width: 100%;
      min-height: 100px;
      padding: 10px;
      border: 1px solid #cbd5e0;
      border-radius: 4px;
      font-family: inherit;
      resize: vertical;
    }
    
    .button-group {
      display: flex;
      gap: 10px;
      margin-top: 15px;
    }
    
    button {
      padding: 10px 20px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 500;
      transition: all 0.2s;
    }
    
    .btn-primary {
      background: #667eea;
      color: white;
    }
    
    .btn-primary:hover {
      background: #5568d3;
    }
    
    .btn-secondary {
      background: #718096;
      color: white;
    }
    
    .btn-secondary:hover {
      background: #4a5568;
    }
    
    .btn-success {
      background: #48bb78;
      color: white;
    }
    
    .btn-success:hover {
      background: #38a169;
    }

    .btn-danger {
      background: #e53e3e;
      color: white;
    }

    .btn-danger:hover {
      background: #c53030;
    }
    
    .memory-list {
      list-style: none;
      padding: 0;
    }
    
    .memory-item {
      background: #f7fafc;
      padding: 12px;
      margin-bottom: 8px;
      border-radius: 4px;
      border-left: 3px solid #667eea;
    }
    
    .post-list {
      max-height: 600px;
      overflow-y: auto;
    }
    
    .post-item {
      background: #f7fafc;
      padding: 15px;
      margin-bottom: 10px;
      border-radius: 4px;
      border-left: 3px solid #48bb78;
    }
    
    .post-meta {
      color: #718096;
      font-size: 0.9em;
      margin-top: 8px;
    }
    
    .preview-box {
      background: #edf2f7;
      padding: 15px;
      border-radius: 4px;
      margin-top: 10px;
      border: 1px solid #cbd5e0;
    }
    
    .status {
      padding: 4px 8px;
      border-radius: 3px;
      font-size: 0.85em;
      font-weight: 500;
    }
    
    .status-active {
      background: #c6f6d5;
      color: #22543d;
    }
    
    .status-immortal {
      background: #fed7d7;
      color: #742a2a;
    }
    
    .loading {
      text-align: center;
      padding: 40px;
      color: #718096;
    }
    
    .error {
      background: #fed7d7;
      color: #742a2a;
      padding: 12px;
      border-radius: 4px;
      margin-bottom: 15px;
    }
    
    .success {
      background: #c6f6d5;
      color: #22543d;
      padding: 12px;
      border-radius: 4px;
      margin-bottom: 15px;
    }
  </style>
</head>
<body class="bg-gray-100">
  <div class="min-h-screen flex flex-col">
    <!-- Legacy nav will be replaced by admin-shell.js if present -->
    <nav class="bg-gray-800 text-white shadow-lg" data-legacy-nav>
      <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div class="flex items-center justify-between h-16">
          <div class="flex items-center">
            <div class="flex-shrink-0">
              <h1 class="text-xl font-bold">RATi Admin Panel</h1>
            </div>
            <div class="ml-10 flex items-baseline space-x-4">
              <a href="/admin" class="px-3 py-2 rounded-md text-sm font-medium text-gray-300 hover:text-white hover:bg-gray-700">Dashboard</a>
              <a href="/admin/entity-management" class="px-3 py-2 rounded-md text-sm font-medium text-gray-300 hover:text-white hover:bg-gray-700">Entity Management</a>
              <a href="/admin/x-accounts" class="px-3 py-2 rounded-md text-sm font-medium text-gray-300 hover:text-white hover:bg-gray-700">X Accounts</a>
              <a href="/admin/global-bot" class="px-3 py-2 rounded-md text-sm font-medium text-white bg-gray-700">Global Bot</a>
              <a href="/admin/collections" class="px-3 py-2 rounded-md text-sm font-medium text-gray-300 hover:text-white hover:bg-gray-700">Collections</a>
              <a href="/admin/settings" class="px-3 py-2 rounded-md text-sm font-medium text-gray-300 hover:text-white hover:bg-gray-700">Settings</a>
            </div>
          </div>
          <div>
            <button id="admin-logout" class="px-3 py-1 text-sm bg-gray-700 hover:bg-gray-600 rounded">Logout</button>
          </div>
        </div>
      </div>
    </nav>

    <main class="flex-grow">
      <div class="max-w-7xl mx-auto py-6 sm:px-6 lg:px-8">
        <div class="px-4 py-6 sm:px-0">
          <h1 class="text-3xl font-bold text-gray-900 mb-6">üåç Global Bot Management</h1>
          
          <div id="status-message"></div>
          
          <!-- Persona Section -->
          <div class="section">
      <h2>Bot Persona</h2>
      <div id="persona-loading" class="loading">Loading persona...</div>
      <div id="persona-content" style="display: none;">
        <div class="persona-info">
          <div class="info-card">
            <label>Name</label>
            <div id="bot-name"></div>
          </div>
          <div class="info-card">
            <label>Emoji</label>
            <div id="bot-emoji" style="font-size: 2em;"></div>
          </div>
          <div class="info-card">
            <label>Status</label>
            <div id="bot-status"></div>
          </div>
          <div class="info-card">
            <label>Model</label>
            <div id="bot-model"></div>
          </div>
        </div>
        
        <div style="margin-top: 20px;">
          <label for="model-provider">AI Provider</label>
          <select id="model-provider" style="width: 100%; padding: 10px; border: 1px solid #cbd5e0; border-radius: 4px; font-family: inherit; margin-bottom: 10px;">
            <option value="">Loading providers...</option>
          </select>
          
          <label for="model-name">Model</label>
          <select id="model-name" style="width: 100%; padding: 10px; border: 1px solid #cbd5e0; border-radius: 4px; font-family: inherit;" disabled>
            <option value="">Select provider first</option>
          </select>
          <p style="color: #718096; font-size: 0.9em; margin-top: 5px;">
            Select the AI model for generating global bot posts. Claude 3.5 Sonnet is recommended for best quality.
          </p>
        </div>
        
        <div style="margin-top: 20px;">
          <label for="personality-textarea">Core Personality</label>
          <textarea id="personality-textarea"></textarea>
        </div>
        
        <div style="margin-top: 20px;">
          <label for="dynamic-prompt-textarea">Current Perspective (Dynamic Prompt)</label>
          <textarea id="dynamic-prompt-textarea"></textarea>
          <p style="color: #718096; font-size: 0.9em; margin-top: 5px;">
            This evolves automatically as the bot welcomes new avatars and reflects on its experiences.
          </p>
        </div>
        
        <!-- Universe Name Configuration -->
        <div style="margin-top: 20px;">
          <label for="universe-name-input">Universe Name</label>
          <input type="text" id="universe-name-input" placeholder="e.g., CosyWorld" style="width: 100%; padding: 8px; border: 1px solid #cbd5e0; border-radius: 4px;">
          <p style="color: #718096; font-size: 0.9em; margin-top: 5px;">
            The name of your universe/world. Used throughout all prompts. Defaults to "CosyWorld".
          </p>
        </div>
        
        <!-- Advanced Prompt Templates -->
        <details style="margin-top: 20px; background: #f7fafc; padding: 15px; border-radius: 6px; border: 1px solid #cbd5e0;">
          <summary style="cursor: pointer; font-weight: 600; color: #4a5568; user-select: none;">
            üîß Advanced Prompt Templates (Click to expand)
          </summary>
          
          <div style="margin-top: 15px;">
            <p style="color: #718096; font-size: 0.9em; margin-bottom: 15px;">
              Customize the AI prompts used for different types of posts. Use <code>{{variable}}</code> syntax for replaceable parts.
            </p>
            
            <div style="margin-bottom: 15px;">
              <label for="system-prompt-template">System Prompt Template</label>
              <textarea id="system-prompt-template" style="min-height: 120px;"></textarea>
              <p style="color: #718096; font-size: 0.85em; margin-top: 3px;">
                Variables: {{botName}}, {{botEmoji}}, {{universeName}}, {{personality}}, {{dynamicPrompt}}
              </p>
            </div>
            
            <div style="margin-bottom: 15px;">
              <label for="avatar-intro-prompt-template">Avatar Introduction Prompt</label>
              <textarea id="avatar-intro-prompt-template" style="min-height: 100px;"></textarea>
              <p style="color: #718096; font-size: 0.85em; margin-top: 3px;">
                Variables: {{avatarName}}, {{avatarEmoji}}, {{description}}, {{memories}}
              </p>
            </div>
            
            <div style="margin-bottom: 15px;">
              <label for="location-discovery-prompt-template">Location Discovery Prompt</label>
              <textarea id="location-discovery-prompt-template" style="min-height: 100px;"></textarea>
              <p style="color: #718096; font-size: 0.85em; margin-top: 3px;">
                Variables: {{locationName}}, {{locationEmoji}}, {{description}}, {{memories}}
              </p>
            </div>
            
            <div style="margin-bottom: 15px;">
              <label for="scene-prompt-template">Scene Update Prompt</label>
              <textarea id="scene-prompt-template" style="min-height: 100px;"></textarea>
              <p style="color: #718096; font-size: 0.85em; margin-top: 3px;">
                Variables: {{description}}, {{memories}}
              </p>
            </div>
            
            <div style="margin-bottom: 15px;">
              <label for="combat-prompt-template">Combat Event Prompt</label>
              <textarea id="combat-prompt-template" style="min-height: 100px;"></textarea>
              <p style="color: #718096; font-size: 0.85em; margin-top: 3px;">
                Variables: {{description}}, {{memories}}
              </p>
            </div>
            
            <div style="margin-bottom: 15px;">
              <label for="generic-prompt-template">Generic Event Prompt</label>
              <textarea id="generic-prompt-template" style="min-height: 100px;"></textarea>
              <p style="color: #718096; font-size: 0.85em; margin-top: 3px;">
                Variables: {{description}}, {{memories}}
              </p>
            </div>
            
            <div style="margin-bottom: 15px;">
              <label for="narrative-reflection-prompt-template">Narrative Reflection Prompt</label>
              <textarea id="narrative-reflection-prompt-template" style="min-height: 100px;"></textarea>
              <p style="color: #718096; font-size: 0.85em; margin-top: 3px;">
                Variables: {{memories}}, {{universeName}}
              </p>
            </div>
          </div>
        </details>
        
        <!-- Character Design Section for Consistent Image Generation -->
        <details style="margin-top: 20px; background: #f0f9ff; padding: 15px; border-radius: 6px; border: 2px solid #3b82f6;">
          <summary style="cursor: pointer; font-weight: 600; color: #1e40af; user-select: none;">
            üé® Character Design for Image Generation (Click to expand)
          </summary>
          
          <div style="margin-top: 15px;">
            <p style="color: #1e3a8a; font-size: 0.95em; margin-bottom: 15px; padding: 10px; background: #dbeafe; border-radius: 4px;">
              <strong>‚ú® Feature:</strong> Configure a consistent character that will appear in all images generated by the global bot. 
              Upload a reference image and provide a description to ensure your character appears consistently across all generated content.
            </p>
            
            <div style="margin-bottom: 15px;">
              <label style="display: flex; align-items: center; gap: 8px;">
                <input type="checkbox" id="character-enabled" style="width: auto; height: 18px; cursor: pointer;">
                <span style="font-weight: 600;">Enable Character in Image Generation</span>
              </label>
              <p style="color: #718096; font-size: 0.85em; margin-top: 5px; margin-left: 26px;">
                When enabled, all images will feature your character
              </p>
            </div>
            
            <div style="margin-bottom: 15px;">
              <label for="character-name">Character Name</label>
              <input type="text" id="character-name" placeholder="e.g., CosyBot" style="width: 100%; padding: 8px; border: 1px solid #cbd5e0; border-radius: 4px;">
              <p style="color: #718096; font-size: 0.85em; margin-top: 3px;">
                Name to use when referring to the character in prompts
              </p>
            </div>
            
            <div style="margin-bottom: 15px;">
              <label for="character-reference-url">Character Reference Image URL</label>
              <div style="display: flex; gap: 10px; align-items: center;">
                <input type="text" id="character-reference-url" placeholder="https://..." style="flex: 1; padding: 8px; border: 1px solid #cbd5e0; border-radius: 4px;">
                <input type="file" id="character-upload-input" accept="image/*" style="display: none;" onchange="uploadCharacterImage(this)">
                <button class="btn-secondary" onclick="document.getElementById('character-upload-input').click()" style="white-space: nowrap;">
                  üì§ Upload
                </button>
              </div>
              <p style="color: #718096; font-size: 0.85em; margin-top: 3px;">
                URL of the character reference image (upload to S3 or use public URL)
              </p>
              <div id="character-preview" style="margin-top: 10px; display: none;">
                <img id="character-preview-img" style="max-width: 200px; max-height: 200px; border-radius: 8px; border: 2px solid #cbd5e0;">
              </div>
            </div>
            
            <div style="margin-bottom: 15px;">
              <label for="character-description">Character Description</label>
              <textarea id="character-description" placeholder="e.g., A friendly robot with blue metallic body, glowing green eyes, wearing a red scarf. Has rounded features and a warm smile." style="min-height: 100px;"></textarea>
              <p style="color: #718096; font-size: 0.85em; margin-top: 3px;">
                Detailed visual description of the character (appearance, clothing, distinctive features). This will be injected into image generation prompts.
              </p>
            </div>
            
            <div style="margin-bottom: 15px;">
              <label for="character-prompt-prefix">Image Prompt Prefix Template</label>
              <textarea id="character-prompt-prefix" placeholder="Show {{characterName}} ({{characterDescription}}) in this situation: " style="min-height: 80px;"></textarea>
              <p style="color: #718096; font-size: 0.85em; margin-top: 3px;">
                Template prepended to all image generation prompts. Variables: {{characterName}}, {{characterDescription}}
              </p>
            </div>
            
            <button class="btn-secondary" onclick="previewCharacterImage()" style="margin-top: 10px;">
              üëÅÔ∏è Preview Character Image
            </button>
          </div>
        </details>
        
        <div class="button-group">
          <button class="btn-primary" onclick="savePersona()">üíæ Save Persona</button>
          <button class="btn-secondary" onclick="generateNarrative()">üîÑ Generate New Narrative</button>
          <button class="btn-secondary" onclick="loadPersona()">‚Üª Refresh</button>
        </div>
      </div>
    </div>
    
    <!-- Telegram Configuration Section -->
    <div class="section" id="telegram-config-section">
      <h2>Telegram Global Bot</h2>
      <p class="text-sm text-gray-600 mb-3">Manage the Telegram bot token, channel, and auto-posting behavior that power the global bot.</p>

      <div class="flex items-center justify-between flex-wrap gap-3 mb-3">
        <div id="telegram-config-summary" class="text-sm text-gray-700">Loading Telegram configuration...</div>
        <div class="flex items-center gap-2">
          <button id="telegram-refresh-btn" class="btn-secondary">Refresh</button>
          <button id="telegram-test-btn" class="btn-primary">Test Bot</button>
        </div>
      </div>

      <div id="telegram-config-alert" class="hidden mb-4">
        <div class="p-2 rounded text-sm"></div>
      </div>

      <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-1" for="telegram-bot-token">Bot Token</label>
          <div class="flex gap-2">
            <input type="password" id="telegram-bot-token" class="flex-1 border-gray-300 rounded-md shadow-sm px-3 py-2" placeholder="Enter token from @BotFather" />
            <button id="telegram-save-token-btn" class="btn-success">Save Token</button>
          </div>
          <p class="mt-1 text-xs text-gray-500" id="telegram-token-status">Token status unknown.</p>
        </div>
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-1" for="telegram-channel-id">Channel or Chat ID</label>
          <div class="flex gap-2">
            <input type="text" id="telegram-channel-id" class="flex-1 border-gray-300 rounded-md shadow-sm px-3 py-2" placeholder="@channel or -1001234567890" />
            <button id="telegram-save-channel-btn" class="btn-success">Save Channel</button>
          </div>
          <p class="mt-1 text-xs text-gray-500" id="telegram-channel-status">Channel status unknown.</p>
        </div>
      </div>

      <div class="mt-6">
        <div class="flex items-center justify-between flex-wrap gap-2 mb-3">
          <h3 class="text-base font-medium text-gray-900">Auto-Posting Configuration</h3>
          <button id="telegram-save-config-btn" class="btn-success">Save Posting Config</button>
        </div>
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-1" for="telegram-config-enabled">Auto-Posting</label>
            <select id="telegram-config-enabled" class="w-full border-gray-300 rounded-md shadow-sm px-3 py-2">
              <option value="true">Enabled</option>
              <option value="false">Disabled</option>
            </select>
          </div>
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-1" for="telegram-config-hourly">Hourly Limit</label>
            <input type="number" id="telegram-config-hourly" class="w-full border-gray-300 rounded-md shadow-sm px-3 py-2" min="1" placeholder="10" />
          </div>
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-1" for="telegram-config-min-interval">Min Interval (sec)</label>
            <input type="number" id="telegram-config-min-interval" class="w-full border-gray-300 rounded-md shadow-sm px-3 py-2" min="60" placeholder="180" />
          </div>
        </div>
        <p class="mt-2 text-xs text-gray-500" id="telegram-posting-status">Auto-posting status unknown.</p>
      </div>

      <div class="mt-4">
        <pre id="telegram-diag-log" class="text-xs bg-gray-50 p-3 rounded border overflow-auto" style="max-height: 160px;">Ready...</pre>
      </div>
    </div>

    <!-- Stats Section -->
    <div class="section">
      <h2>Statistics</h2>
      <div class="persona-info">
        <div class="info-card">
          <label>Total Introductions</label>
          <div id="stat-intros">-</div>
        </div>
        <div class="info-card">
          <label>Memories Stored</label>
          <div id="stat-memories">-</div>
        </div>
      </div>
    </div>
    
    <!-- Recent Memories -->
    <div class="section">
      <div class="flex items-center justify-between flex-wrap gap-3 mb-3">
        <h2 class="m-0">Recent Memories</h2>
        <div class="flex items-center gap-2">
          <button class="btn-secondary" onclick="loadPersona()">‚Üª Refresh</button>
          <button class="btn-danger" onclick="clearAllMemories()">üóëÔ∏è Clear All</button>
        </div>
      </div>
      <p class="text-sm text-gray-600 mb-3">These are the latest memories the global bot will use for context. Delete individual entries that are outdated or inaccurate.</p>
      <ul id="memory-list" class="memory-list"></ul>
    </div>
    
    <!-- Preview Generator -->
    <div class="section">
      <h2>Preview Post Generation</h2>
      <p>Test how the bot would introduce a new avatar:</p>
      
      <div style="margin-top: 15px;">
        <label for="preview-name">Avatar Name</label>
        <input type="text" id="preview-name" placeholder="e.g., Zanara the Mystic" style="width: 100%; padding: 8px; border: 1px solid #cbd5e0; border-radius: 4px;">
      </div>
      
      <div style="margin-top: 15px;">
        <label for="preview-emoji">Avatar Emoji</label>
        <input type="text" id="preview-emoji" placeholder="e.g., üîÆ" style="width: 100px; padding: 8px; border: 1px solid #cbd5e0; border-radius: 4px;">
      </div>
      
      <div style="margin-top: 15px;">
        <label for="preview-description">Description</label>
        <textarea id="preview-description" placeholder="e.g., A mystical seer with ancient powers..." style="min-height: 80px;"></textarea>
      </div>
      
      <button class="btn-success" onclick="generatePreview()" style="margin-top: 10px;">‚ú® Generate Preview</button>
      
      <div id="preview-result" class="preview-box" style="display: none;">
        <strong>Generated Post:</strong>
        <div id="preview-text" style="margin-top: 10px; font-size: 1.1em;"></div>
      </div>
    </div>
    
    <!-- Recent Posts -->
    <div class="section">
      <h2>Recent Posts</h2>
      <div id="posts-loading" class="loading">Loading posts...</div>
      <div id="posts-list" class="post-list" style="display: none;"></div>
    </div>
  </div>
  
  <script>
    // Global variables
    let modelsByProvider = new Map();
    let currentBotModel = null;

    const telegramState = {
      hasBotToken: false,
      hasChannel: false,
      channelId: '',
      enabled: false,
      rate: { hourly: 10, minIntervalSec: 180 },
      lastBotInfo: null
    };

    const telegramEls = {
      section: document.getElementById('telegram-config-section'),
      summary: document.getElementById('telegram-config-summary'),
      alert: document.getElementById('telegram-config-alert'),
      alertBox: document.getElementById('telegram-config-alert')?.querySelector('div') || null,
      tokenInput: document.getElementById('telegram-bot-token'),
      tokenStatus: document.getElementById('telegram-token-status'),
      saveTokenBtn: document.getElementById('telegram-save-token-btn'),
      channelInput: document.getElementById('telegram-channel-id'),
      channelStatus: document.getElementById('telegram-channel-status'),
      saveChannelBtn: document.getElementById('telegram-save-channel-btn'),
      enabledSelect: document.getElementById('telegram-config-enabled'),
      hourlyInput: document.getElementById('telegram-config-hourly'),
      minIntervalInput: document.getElementById('telegram-config-min-interval'),
      saveConfigBtn: document.getElementById('telegram-save-config-btn'),
      postingStatus: document.getElementById('telegram-posting-status'),
      refreshBtn: document.getElementById('telegram-refresh-btn'),
      testBtn: document.getElementById('telegram-test-btn'),
      diag: document.getElementById('telegram-diag-log')
    };
    
    // Load available models from API
    async function loadModels() {
      try {
        console.log('[Model Selector] Loading models from API...');
        const response = await fetch('/api/models/config');
        if (!response.ok) throw new Error(`HTTP error ${response.status}`);
        
        const modelsData = await response.json();
        console.log('[Model Selector] Received', modelsData.length, 'models from API');
        const modelNames = Array.isArray(modelsData) ? modelsData.map(m => m?.model).filter(Boolean) : [];
        
        // Build provider map
        modelsByProvider.clear();
        modelNames.forEach((fullModel) => {
          const [provider, ...modelParts] = fullModel.split('/');
          const modelName = modelParts.join('/');
          if (provider && modelName) {
            if (!modelsByProvider.has(provider)) {
              modelsByProvider.set(provider, []);
            }
            modelsByProvider.get(provider).push({
              fullName: fullModel,
              modelName: modelName
            });
          }
        });
        
        console.log('[Model Selector] Organized into', modelsByProvider.size, 'providers');
        console.log('[Model Selector] Providers:', Array.from(modelsByProvider.keys()).join(', '));
        
        // Initialize the dropdowns
        initializeModelSelectors();
        console.log('[Model Selector] Initialization complete');
      } catch (error) {
        console.error('[Model Selector] Error loading models:', error);
      }
    }
    
    // Initialize provider/model dropdowns
    function initializeModelSelectors() {
      const providerSelect = document.getElementById('model-provider');
      const modelNameSelect = document.getElementById('model-name');
      
      if (!providerSelect || !modelNameSelect) return;
      
      // Clear and populate provider dropdown
      providerSelect.innerHTML = '<option value="">Select provider...</option>';
      const providers = Array.from(modelsByProvider.keys()).sort();
      
      providers.forEach(provider => {
        const option = document.createElement('option');
        option.value = provider;
        option.textContent = provider;
        providerSelect.appendChild(option);
      });
      
      // Reset model dropdown
      modelNameSelect.innerHTML = '<option value="">Select provider first</option>';
      modelNameSelect.disabled = true;
      
      // Provider change handler
      providerSelect.onchange = () => {
        const selectedProvider = providerSelect.value;
        console.log('[Model Selector] Provider changed to:', selectedProvider);
        modelNameSelect.innerHTML = '';
        modelNameSelect.disabled = !selectedProvider;
        
        if (selectedProvider) {
          const models = modelsByProvider.get(selectedProvider) || [];
          console.log('[Model Selector] Loading', models.length, 'models for provider:', selectedProvider);
          
          models.forEach(modelInfo => {
            const option = document.createElement('option');
            option.value = modelInfo.fullName;
            option.textContent = modelInfo.modelName;
            modelNameSelect.appendChild(option);
          });
          
          // Try to select the current model if it's in this provider
          if (currentBotModel && currentBotModel.startsWith(selectedProvider + '/')) {
            console.log('[Model Selector] Selecting current model:', currentBotModel);
            modelNameSelect.value = currentBotModel;
          }
        }
      };
    }
    
    // Set the current model in the dropdowns
    function setCurrentModel(modelFullName) {
      currentBotModel = modelFullName;
      console.log('[Model Selector] Setting current model:', modelFullName);
      
      if (!modelFullName) {
        console.warn('[Model Selector] No model provided');
        return;
      }
      
      if (modelsByProvider.size === 0) {
        console.warn('[Model Selector] Models not loaded yet, will retry');
        // Retry after a short delay
        setTimeout(() => setCurrentModel(modelFullName), 200);
        return;
      }
      
      const [provider] = modelFullName.split('/');
      const providerSelect = document.getElementById('model-provider');
      const modelNameSelect = document.getElementById('model-name');
      
      if (!provider || !providerSelect || !modelNameSelect) {
        console.error('[Model Selector] Missing elements or invalid model format');
        return;
      }
      
      // Check if provider exists
      if (!modelsByProvider.has(provider)) {
        console.error('[Model Selector] Provider not found:', provider);
        console.log('[Model Selector] Available providers:', Array.from(modelsByProvider.keys()));
        return;
      }
      
      console.log('[Model Selector] Setting provider to:', provider);
      providerSelect.value = provider;
      
      // Manually populate the model dropdown (don't rely on event timing)
      const models = modelsByProvider.get(provider) || [];
      console.log('[Model Selector] Manually populating', models.length, 'models');
      
      modelNameSelect.innerHTML = '';
      modelNameSelect.disabled = false;
      
      models.forEach(modelInfo => {
        const option = document.createElement('option');
        option.value = modelInfo.fullName;
        option.textContent = modelInfo.modelName;
        modelNameSelect.appendChild(option);
      });
      
      // Now set the specific model
      console.log('[Model Selector] Setting model to:', modelFullName);
      modelNameSelect.value = modelFullName;
      
      // If the model doesn't exist, try to find a reasonable fallback
      if (modelNameSelect.value !== modelFullName) {
        console.warn('[Model Selector] Model not found:', modelFullName);
        console.log('[Model Selector] Available options:', Array.from(modelNameSelect.options).map(o => o.value));
        
        // Try fallback strategies for common models
        let fallback = null;
        const availableModels = Array.from(modelNameSelect.options).map(o => o.value);
        
        if (modelFullName.includes('claude-3.5-sonnet')) {
          // Try newer Claude Sonnet versions
          fallback = availableModels.find(m => m.includes('claude-sonnet-4.5')) ||
                     availableModels.find(m => m.includes('claude-sonnet-4')) ||
                     availableModels.find(m => m.includes('claude-3.7-sonnet')) ||
                     availableModels.find(m => m.includes('sonnet'));
        } else if (modelFullName.includes('claude-3.5-haiku')) {
          fallback = availableModels.find(m => m.includes('claude-haiku-4.5')) ||
                     availableModels.find(m => m.includes('claude-3.5-haiku'));
        } else if (modelFullName.includes('claude')) {
          // Generic Claude fallback - prefer Sonnet
          fallback = availableModels.find(m => m.includes('sonnet')) ||
                     availableModels.find(m => m.includes('claude'));
        }
        
        // If still no fallback, just use the first available model for this provider
        if (!fallback && models.length > 0) {
          fallback = models[0].fullName;
        }
        
        if (fallback) {
          console.log('[Model Selector] Using fallback model:', fallback);
          modelNameSelect.value = fallback;
          showStatus(`Model "${modelFullName}" not available, using "${fallback}" instead`);
        } else {
          console.error('[Model Selector] No fallback available');
        }
      } else {
        console.log('[Model Selector] Model set successfully');
      }
    }
    
    // Get the currently selected model
    function getCurrentModel() {
      const modelNameSelect = document.getElementById('model-name');
      const value = modelNameSelect?.value || null;
      console.log('[Model Selector] Getting current model:', value);
      return value;
    }
    
    // Load persona data
    async function loadPersona() {
      try {
        document.getElementById('persona-loading').style.display = 'block';
        document.getElementById('persona-content').style.display = 'none';
        
        const res = await fetch('/api/admin/global-bot/persona');
        const data = await res.json();
        
        if (!data.success) {
          throw new Error(data.error || 'Failed to load persona');
        }
        
        const { bot, memories, stats } = data.persona;
        
        // Update persona fields
        document.getElementById('bot-name').textContent = bot.name || 'Unknown';
        document.getElementById('bot-emoji').textContent = bot.emoji || 'üåç';
        document.getElementById('bot-status').innerHTML = `<span class="status status-${bot.status}">${bot.status}</span>`;
        document.getElementById('bot-model').textContent = bot.model || 'Unknown';
        setCurrentModel(bot.model || 'anthropic/claude-3.5-sonnet');
        document.getElementById('personality-textarea').value = bot.personality || '';
        document.getElementById('dynamic-prompt-textarea').value = bot.dynamicPrompt || '';
        
        // Load universe name and prompt templates
        const config = bot.globalBotConfig || {};
        document.getElementById('universe-name-input').value = config.universeName || '';
        document.getElementById('system-prompt-template').value = config.systemPromptTemplate || '';
        document.getElementById('avatar-intro-prompt-template').value = config.avatarIntroPromptTemplate || '';
        document.getElementById('location-discovery-prompt-template').value = config.locationDiscoveryPromptTemplate || '';
        document.getElementById('scene-prompt-template').value = config.scenePromptTemplate || '';
        document.getElementById('combat-prompt-template').value = config.combatPromptTemplate || '';
        document.getElementById('generic-prompt-template').value = config.genericPromptTemplate || '';
        document.getElementById('narrative-reflection-prompt-template').value = config.narrativeReflectionPromptTemplate || '';
        
        // Load character design settings
        const charDesign = config.characterDesign || {};
        document.getElementById('character-enabled').checked = charDesign.enabled || false;
        document.getElementById('character-name').value = charDesign.characterName || config.universeName || '';
        document.getElementById('character-reference-url').value = charDesign.referenceImageUrl || '';
        document.getElementById('character-description').value = charDesign.characterDescription || '';
        document.getElementById('character-prompt-prefix').value = charDesign.imagePromptPrefix || 'Show {{characterName}} ({{characterDescription}}) in this situation: ';
        
        // Show character preview if URL exists
        if (charDesign.referenceImageUrl) {
          const previewDiv = document.getElementById('character-preview');
          const previewImg = document.getElementById('character-preview-img');
          previewImg.src = charDesign.referenceImageUrl;
          previewDiv.style.display = 'block';
        }
        
        // Update stats
        document.getElementById('stat-intros').textContent = stats.totalIntroductions || 0;
        document.getElementById('stat-memories').textContent = stats.memoryCount || 0;
        
        renderMemoryList(memories || []);
        
        document.getElementById('persona-loading').style.display = 'none';
        document.getElementById('persona-content').style.display = 'block';
      } catch (err) {
        showError('Failed to load persona: ' + err.message);
        document.getElementById('persona-loading').style.display = 'none';
      }
    }
    
    // Save persona changes
    async function savePersona() {
      try {
        const selectedModel = getCurrentModel();
        if (!selectedModel) {
          showError('Please select a model');
          return;
        }
        
        const updates = {
          personality: document.getElementById('personality-textarea').value,
          dynamicPrompt: document.getElementById('dynamic-prompt-textarea').value,
          model: selectedModel,
          globalBotConfig: {
            universeName: document.getElementById('universe-name-input').value || 'CosyWorld',
            systemPromptTemplate: document.getElementById('system-prompt-template').value || '',
            avatarIntroPromptTemplate: document.getElementById('avatar-intro-prompt-template').value || '',
            locationDiscoveryPromptTemplate: document.getElementById('location-discovery-prompt-template').value || '',
            scenePromptTemplate: document.getElementById('scene-prompt-template').value || '',
            combatPromptTemplate: document.getElementById('combat-prompt-template').value || '',
            genericPromptTemplate: document.getElementById('generic-prompt-template').value || '',
            narrativeReflectionPromptTemplate: document.getElementById('narrative-reflection-prompt-template').value || '',
            characterDesign: {
              enabled: document.getElementById('character-enabled').checked,
              characterName: document.getElementById('character-name').value || '',
              referenceImageUrl: document.getElementById('character-reference-url').value || '',
              characterDescription: document.getElementById('character-description').value || '',
              imagePromptPrefix: document.getElementById('character-prompt-prefix').value || 'Show {{characterName}} ({{characterDescription}}) in this situation: '
            }
          }
        };
        
        console.log('[Save] Saving with model:', selectedModel);
        console.log('[Save] Saving universe name:', updates.globalBotConfig.universeName);
        
        // Use AdminAPI with CSRF and signing
        const data = await window.AdminAPI.apiFetch('/api/admin/global-bot/persona', {
          method: 'PUT',
          body: updates,
          requireCsrf: true,
          sign: true
        });
        
        if (!data.success) {
          throw new Error(data.error || 'Save failed');
        }
        
        showSuccess('Persona and templates saved successfully!');
        
        // Update the display model text
        if (data.bot && data.bot.model) {
          document.getElementById('bot-model').textContent = data.bot.model;
          console.log('[Save] Model updated to:', data.bot.model);
        }
      } catch (err) {
        const errMsg = err.message || err.error || String(err);
        showError('Failed to save persona: ' + errMsg);
        console.error('[Save] Error:', err);
      }
    }

    function formatMemoryTimestamp(timestamp) {
      if (!timestamp) return '';
      const date = timestamp instanceof Date ? timestamp : new Date(timestamp);
      if (Number.isNaN(date.getTime())) return '';
      return date.toLocaleString();
    }

    function renderMemoryList(memories) {
      const memoryList = document.getElementById('memory-list');
      if (!memoryList) return;

      memoryList.innerHTML = '';

      if (!memories.length) {
        memoryList.innerHTML = '<li class="memory-item">No memories yet</li>';
        return;
      }

      memories.forEach((mem) => {
        const li = document.createElement('li');
        li.className = 'memory-item flex flex-col gap-2 md:flex-row md:items-center md:justify-between';

        const content = document.createElement('div');
        content.className = 'memory-text';
        content.textContent = mem.memory || mem.text || 'Empty memory';

        const meta = document.createElement('div');
        meta.className = 'text-xs text-gray-500 flex items-center gap-3';

        if (mem.kind) {
          const kindBadge = document.createElement('span');
          kindBadge.className = 'px-2 py-0.5 bg-indigo-50 text-indigo-700 rounded-full';
          kindBadge.textContent = mem.kind;
          meta.appendChild(kindBadge);
        }

        const tsText = formatMemoryTimestamp(mem.timestamp);
        if (tsText) {
          const timeSpan = document.createElement('span');
          timeSpan.textContent = tsText;
          meta.appendChild(timeSpan);
        }

        if (typeof mem.weight === 'number') {
          const weightSpan = document.createElement('span');
          weightSpan.textContent = `weight ${mem.weight.toFixed(2)}`;
          meta.appendChild(weightSpan);
        }

        const actions = document.createElement('div');
        actions.className = 'flex items-center gap-2 mt-1 md:mt-0';

        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'btn-danger';
        deleteBtn.style.padding = '6px 12px';
        deleteBtn.textContent = 'Delete';
        deleteBtn.onclick = () => deleteMemory(mem.id, li);

        actions.appendChild(deleteBtn);

        const metaRow = document.createElement('div');
        metaRow.className = 'flex flex-col md:flex-row md:items-center md:justify-end gap-2';
        metaRow.appendChild(meta);
        metaRow.appendChild(actions);

        li.appendChild(content);
        li.appendChild(metaRow);
        memoryList.appendChild(li);
      });
    }

    async function deleteMemory(memoryId, listItem) {
      if (!memoryId) {
        showError('Missing memory ID.');
        return;
      }

      if (!confirm('Delete this memory? This cannot be undone.')) {
        return;
      }

      try {
        const data = await window.AdminAPI.apiFetch(`/api/admin/global-bot/memories/${memoryId}`, {
          method: 'DELETE',
          requireCsrf: true,
          sign: true,
          signMeta: { op: 'delete_memory', memoryId }
        });

        if (!data.success) {
          throw new Error(data.error || 'Delete failed');
        }

        listItem?.remove?.();

        const statEl = document.getElementById('stat-memories');
        if (statEl) {
          const current = parseInt(statEl.textContent || '0', 10);
          statEl.textContent = Math.max(0, current - 1);
        }

        const memoryList = document.getElementById('memory-list');
        if (memoryList && !memoryList.children.length) {
          memoryList.innerHTML = '<li class="memory-item">No memories yet</li>';
        }

        showSuccess('Memory deleted');
      } catch (err) {
        const errMsg = err?.message || err?.error || String(err);
        showError('Failed to delete memory: ' + errMsg);
      }
    }

    async function clearAllMemories() {
      if (!confirm('Are you sure you want to delete all global bot memories? This action cannot be undone.')) {
        return;
      }

      try {
        const data = await window.AdminAPI.apiFetch('/api/admin/global-bot/memories', {
          method: 'DELETE',
          body: {},
          requireCsrf: true,
          sign: true,
          signMeta: { op: 'delete_all_memories' }
        });

        if (!data.success) {
          throw new Error(data.error || 'Delete failed');
        }

        const memoryList = document.getElementById('memory-list');
        if (memoryList) {
          memoryList.innerHTML = '<li class="memory-item">No memories yet</li>';
        }

        const statEl = document.getElementById('stat-memories');
        if (statEl) {
          statEl.textContent = '0';
        }

        showSuccess('All memories deleted');
      } catch (err) {
        const errMsg = err?.message || err?.error || String(err);
        showError('Failed to clear memories: ' + errMsg);
      }
    }
    
    // Generate new narrative
    async function generateNarrative() {
      try {
        showStatus('Generating new narrative...');
        
        // Use AdminAPI with CSRF and signing
        const data = await window.AdminAPI.apiFetch('/api/admin/global-bot/generate-narrative', {
          method: 'POST',
          requireCsrf: true,
          sign: true
        });
        
        if (!data.success) {
          throw new Error(data.error || 'Generation failed');
        }
        
        document.getElementById('dynamic-prompt-textarea').value = data.narrative || '';
        showSuccess('New narrative generated!');
      } catch (err) {
        const errMsg = err.message || err.error || String(err);
        showError('Failed to generate narrative: ' + errMsg);
      }
    }
    
    // Generate preview
    async function generatePreview() {
      try {
        const name = document.getElementById('preview-name').value;
        const emoji = document.getElementById('preview-emoji').value;
        const description = document.getElementById('preview-description').value;
        
        if (!name || !description) {
          showError('Please fill in at least name and description');
          return;
        }
        
        showStatus('Generating preview...');
        
        const payload = {
          source: 'avatar.create',
          avatarName: name,
          avatarEmoji: emoji,
          prompt: description
        };
        
        // Use AdminAPI with CSRF and signing
        const data = await window.AdminAPI.apiFetch('/api/admin/global-bot/preview', {
          method: 'POST',
          body: payload,
          requireCsrf: true,
          sign: true
        });
        
        if (!data.success) {
          throw new Error(data.error || 'Preview failed');
        }
        
        document.getElementById('preview-text').textContent = data.preview;
        document.getElementById('preview-result').style.display = 'block';
        clearStatus();
      } catch (err) {
        const errMsg = err.message || err.error || String(err);
        showError('Failed to generate preview: ' + errMsg);
      }
    }
    
    function showTelegramAlert(message, type = 'info') {
      if (!telegramEls.alert || !telegramEls.alertBox) return;
      const palette = {
        success: 'bg-green-50 text-green-800 border border-green-200',
        error: 'bg-red-50 text-red-800 border border-red-200',
        info: 'bg-blue-50 text-blue-800 border border-blue-200'
      };
      telegramEls.alertBox.className = `p-2 rounded text-sm ${palette[type] || palette.info}`;
      telegramEls.alertBox.textContent = message;
      telegramEls.alert.classList.remove('hidden');
      setTimeout(() => telegramEls.alert?.classList.add('hidden'), type === 'error' ? 6000 : 4000);
    }

    // Upload character reference image
    async function uploadCharacterImage(input) {
      if (!input.files || !input.files[0]) return;
      
      const file = input.files[0];
      const formData = new FormData();
      formData.append('image', file);
      
      const btn = input.nextElementSibling; // The upload button
      const originalText = btn.textContent;
      btn.disabled = true;
      btn.textContent = 'Uploading...';
      
      try {
        // Use AdminAPI to handle CSRF and auth headers
        const data = await window.AdminAPI.apiFetch('/api/admin/upload-image', {
          method: 'POST',
          body: formData,
          requireCsrf: true,
          sign: true // Add signature just in case, though mainly CSRF is the blocker
        });
        
        // Update URL input
        const url = data.url || data.imageUrl;
        document.getElementById('character-reference-url').value = url;
        
        // Update preview
        const previewDiv = document.getElementById('character-preview');
        const previewImg = document.getElementById('character-preview-img');
        previewImg.src = url;
        previewDiv.style.display = 'block';
        
        showSuccess('Image uploaded successfully');
      } catch (err) {
        console.error('Upload failed:', err);
        showError('Upload failed: ' + (err.message || 'Unknown error'));
      } finally {
        btn.disabled = false;
        btn.textContent = originalText;
        input.value = '';
      }
    }

    // Preview character reference image
    async function previewCharacterImage() {
      const imageUrl = document.getElementById('character-reference-url').value;
      const previewDiv = document.getElementById('character-preview');
      const previewImg = document.getElementById('character-preview-img');
      
      if (!imageUrl || !imageUrl.trim()) {
        previewDiv.style.display = 'none';
        showError('Please enter a character reference image URL first');
        return;
      }
      
      const btn = document.querySelector('button[onclick="previewCharacterImage()"]');
      const originalText = btn.textContent;
      btn.disabled = true;
      btn.textContent = 'Generating Preview...';
      
      try {
        const characterDesign = {
          enabled: true,
          characterName: document.getElementById('character-name').value || '',
          referenceImageUrl: imageUrl,
          characterDescription: document.getElementById('character-description').value || '',
          imagePromptPrefix: document.getElementById('character-prompt-prefix').value || ''
        };
        
        const res = await window.AdminAPI.apiFetch('/api/admin/global-bot/generate-image', {
          method: 'POST',
          body: {
            prompt: 'standing in a heroic pose, detailed background',
            characterDesign
          },
          requireCsrf: true,
          sign: true
        });
        
        if (!res.success) {
          throw new Error(res.error || 'Generation failed');
        }
        
        previewImg.src = res.imageUrl;
        previewDiv.style.display = 'block';
        
        showSuccess('Preview generated successfully');
      } catch (err) {
        console.error('Preview generation failed:', err);
        showError('Preview generation failed: ' + err.message);
        previewImg.src = imageUrl;
        previewDiv.style.display = 'block';
      } finally {
        btn.disabled = false;
        btn.textContent = originalText;
      }
    }
    
    function clearTelegramAlert() {
      if (!telegramEls.alert) return;
      telegramEls.alert.classList.add('hidden');
    }

    function logTelegramDiag(message, type = 'info') {
      if (!telegramEls.diag) return;
      const now = new Date().toLocaleTimeString();
      const prefix = type === 'error' ? '‚úó' : type === 'success' ? '‚úì' : '‚Ä¢';
      const line = `[${now}] ${prefix} ${message}`;
      const current = telegramEls.diag.textContent || '';
      if (!current || current.trim() === 'Ready...') {
        telegramEls.diag.textContent = line;
      } else {
        telegramEls.diag.textContent = `${current}\n${line}`;
      }
      telegramEls.diag.scrollTop = telegramEls.diag.scrollHeight;
    }

    function updateTelegramUI() {
      if (!telegramEls.section) return;
      const { hasBotToken, hasChannel, channelId, enabled, rate, lastBotInfo } = telegramState;

      if (telegramEls.tokenStatus) {
        telegramEls.tokenStatus.textContent = hasBotToken
          ? 'Token configured. Enter a new token to rotate.'
          : 'Token not configured. Add a token to enable Telegram posting.';
      }

      if (telegramEls.channelStatus) {
        telegramEls.channelStatus.textContent = hasChannel
          ? `Channel configured${channelId ? ` (${channelId})` : ''}.`
          : 'Channel not configured. Add a channel ID to route posts.';
      }

      if (telegramEls.channelInput && document.activeElement !== telegramEls.channelInput) {
        telegramEls.channelInput.value = channelId || '';
      }

      if (telegramEls.enabledSelect) {
        telegramEls.enabledSelect.value = String(enabled);
      }

      if (telegramEls.hourlyInput && document.activeElement !== telegramEls.hourlyInput) {
        telegramEls.hourlyInput.value = rate?.hourly || 10;
      }

      if (telegramEls.minIntervalInput && document.activeElement !== telegramEls.minIntervalInput) {
        telegramEls.minIntervalInput.value = rate?.minIntervalSec || 180;
      }

      const parts = [];
      parts.push(enabled ? 'Auto-posting enabled' : 'Auto-posting disabled');
      if (rate?.hourly) parts.push(`Hourly limit ${rate.hourly}`);
      if (rate?.minIntervalSec) parts.push(`Min interval ${rate.minIntervalSec}s`);
      if (hasChannel && channelId) parts.push(`Channel: ${channelId}`);
      if (lastBotInfo?.username) parts.push(`Bot: @${lastBotInfo.username}`);
      if (telegramEls.summary) {
        telegramEls.summary.textContent = parts.length
          ? parts.join(' ‚Ä¢ ')
          : 'Telegram bot not fully configured yet.';
      }

      if (telegramEls.postingStatus) {
        if (hasBotToken && hasChannel) {
          telegramEls.postingStatus.textContent = `Ready to post${rate?.hourly ? ` up to ${rate.hourly} times per hour` : ''}.`;
          telegramEls.postingStatus.className = 'mt-2 text-xs text-green-600';
        } else {
          telegramEls.postingStatus.textContent = 'Auto-posting disabled until both token and channel are configured.';
          telegramEls.postingStatus.className = 'mt-2 text-xs text-yellow-600';
        }
      }
    }

    async function loadTelegramConfig({ showNotice = false } = {}) {
      if (!telegramEls.section || !window.AdminAPI) return;
      try {
        const data = await window.AdminAPI.apiFetch('/api/telegramauth/global/config');
        telegramState.hasBotToken = !!data?.hasGlobalBot;
        telegramState.hasChannel = !!data?.hasChannelId;
        telegramState.channelId = data?.channelId || '';
        telegramState.enabled = !!data?.enabled;
        telegramState.rate = data?.rate || { hourly: 10, minIntervalSec: 180 };
        updateTelegramUI();
        logTelegramDiag('Configuration loaded.', 'success');
        if (showNotice) {
          showTelegramAlert('Telegram configuration refreshed.', 'success');
        }
      } catch (err) {
        console.error('[TelegramConfig] Failed to load configuration:', err);
        const message = err?.message || 'Failed to load Telegram configuration';
        logTelegramDiag(message, 'error');
        showTelegramAlert(message, 'error');
      }
    }

    async function saveTelegramBotToken() {
      if (!telegramEls.tokenInput) return;
      const token = telegramEls.tokenInput.value.trim();
      if (!token) {
        showError('Please enter a Telegram bot token');
        telegramEls.tokenInput.focus();
        return;
      }

      const btn = telegramEls.saveTokenBtn;
      const originalText = btn?.textContent;
      if (btn) {
        btn.disabled = true;
        btn.textContent = 'Saving...';
      }

      try {
        clearTelegramAlert();
        logTelegramDiag('Saving bot token...');
        await window.AdminAPI.apiFetch('/api/telegramauth/global/token', {
          method: 'POST',
          body: { botToken: token },
          requireCsrf: true,
          sign: true,
          signMeta: { op: 'save_telegram_token' }
        });
        telegramEls.tokenInput.value = '';
        telegramState.hasBotToken = true;
        showSuccess('Telegram bot token saved');
        showTelegramAlert('Bot token saved and bot initialized.', 'success');
        logTelegramDiag('Bot token saved.', 'success');
        await loadTelegramConfig();
      } catch (err) {
        console.error('[TelegramConfig] Failed to save token:', err);
        const message = err?.message || 'Failed to save Telegram bot token';
        showError(message);
        showTelegramAlert(message, 'error');
        logTelegramDiag(message, 'error');
      } finally {
        if (btn) {
          btn.disabled = false;
          btn.textContent = originalText || 'Save Token';
        }
      }
    }

    async function saveTelegramChannelId() {
      if (!telegramEls.channelInput) return;
      const channelId = telegramEls.channelInput.value.trim();
      if (!channelId) {
        showError('Please enter a Telegram channel or chat ID');
        telegramEls.channelInput.focus();
        return;
      }

      const btn = telegramEls.saveChannelBtn;
      const originalText = btn?.textContent;
      if (btn) {
        btn.disabled = true;
        btn.textContent = 'Saving...';
      }

      try {
        clearTelegramAlert();
        logTelegramDiag('Saving channel ID...');
        await window.AdminAPI.apiFetch('/api/telegramauth/global/channel', {
          method: 'POST',
          body: { channelId },
          requireCsrf: true,
          sign: true,
          signMeta: { op: 'save_telegram_channel' }
        });
        telegramState.hasChannel = true;
        telegramState.channelId = channelId;
        showSuccess('Telegram channel saved');
        showTelegramAlert('Channel ID saved.', 'success');
        logTelegramDiag('Channel ID saved.', 'success');
        await loadTelegramConfig();
      } catch (err) {
        console.error('[TelegramConfig] Failed to save channel:', err);
        const message = err?.message || 'Failed to save Telegram channel ID';
        showError(message);
        showTelegramAlert(message, 'error');
        logTelegramDiag(message, 'error');
      } finally {
        if (btn) {
          btn.disabled = false;
          btn.textContent = originalText || 'Save Channel';
        }
      }
    }

    async function saveTelegramPostingConfig() {
      if (!telegramEls.enabledSelect || !telegramEls.saveConfigBtn) return;
      const enabled = telegramEls.enabledSelect.value === 'true';
      const hourly = parseInt(telegramEls.hourlyInput?.value ?? '10', 10) || 10;
      const minInterval = parseInt(telegramEls.minIntervalInput?.value ?? '180', 10) || 180;

      const btn = telegramEls.saveConfigBtn;
      const originalText = btn.textContent;
      btn.disabled = true;
      btn.textContent = 'Saving...';

      try {
        clearTelegramAlert();
        logTelegramDiag('Saving auto-posting configuration...');
        await window.AdminAPI.apiFetch('/api/telegramauth/global/config', {
          method: 'POST',
          body: {
            enabled,
            rate: {
              hourly,
              minIntervalSec: minInterval
            }
          },
          requireCsrf: true,
          sign: true,
          signMeta: { op: 'save_telegram_config' }
        });
        showSuccess('Telegram posting configuration saved');
        showTelegramAlert('Auto-posting configuration saved.', 'success');
        logTelegramDiag('Auto-posting configuration saved.', 'success');
        await loadTelegramConfig();
      } catch (err) {
        console.error('[TelegramConfig] Failed to save posting config:', err);
        const message = err?.message || 'Failed to save auto-posting configuration';
        showError(message);
        showTelegramAlert(message, 'error');
        logTelegramDiag(message, 'error');
      } finally {
        btn.disabled = false;
        btn.textContent = originalText;
      }
    }

    async function testTelegramBot() {
      if (!telegramEls.testBtn) return;
      const btn = telegramEls.testBtn;
      const originalText = btn.textContent;
      btn.disabled = true;
      btn.textContent = 'Testing...';

      try {
        clearTelegramAlert();
        logTelegramDiag('Testing Telegram bot connectivity...');
        const data = await window.AdminAPI.apiFetch('/api/telegramauth/global/test', {
          method: 'POST',
          requireCsrf: true,
          sign: true,
          signMeta: { op: 'test_telegram_bot' }
        });

        if (data?.botInfo) {
          telegramState.lastBotInfo = data.botInfo;
          telegramState.hasBotToken = true;
          updateTelegramUI();
          showSuccess(`Bot connected: @${data.botInfo.username}`);
          showTelegramAlert(`Bot connected: @${data.botInfo.username}`, 'success');
          logTelegramDiag(`Bot connected: @${data.botInfo.username}`, 'success');
        } else {
          showTelegramAlert('Bot test returned an unexpected response.', 'error');
          logTelegramDiag('Bot test returned unexpected response.', 'error');
        }
      } catch (err) {
        console.error('[TelegramConfig] Bot test failed:', err);
        const message = err?.message || 'Telegram bot test failed';
        showError(message);
        showTelegramAlert(message, 'error');
        logTelegramDiag(message, 'error');
      } finally {
        btn.disabled = false;
        btn.textContent = originalText;
      }
    }

    function setupTelegramConfigHandlers() {
      if (!telegramEls.section || setupTelegramConfigHandlers.initialized) return;
      setupTelegramConfigHandlers.initialized = true;

      telegramEls.refreshBtn?.addEventListener('click', async (evt) => {
        evt.preventDefault();
        if (!telegramEls.refreshBtn) return;
        const btn = telegramEls.refreshBtn;
        const originalText = btn.textContent;
        btn.disabled = true;
        btn.textContent = 'Refreshing...';
        try {
          await loadTelegramConfig({ showNotice: true });
        } finally {
          btn.disabled = false;
          btn.textContent = originalText;
        }
      });

      telegramEls.saveTokenBtn?.addEventListener('click', async (evt) => {
        evt.preventDefault();
        await saveTelegramBotToken();
      });

      telegramEls.saveChannelBtn?.addEventListener('click', async (evt) => {
        evt.preventDefault();
        await saveTelegramChannelId();
      });

      telegramEls.saveConfigBtn?.addEventListener('click', async (evt) => {
        evt.preventDefault();
        await saveTelegramPostingConfig();
      });

      telegramEls.testBtn?.addEventListener('click', async (evt) => {
        evt.preventDefault();
        await testTelegramBot();
      });
    }

    // Load recent posts
    async function loadPosts() {
      try {
        const res = await fetch('/api/admin/global-bot/posts?limit=20');
        const data = await res.json();
        
        if (!data.success) {
          throw new Error(data.error || 'Failed to load posts');
        }
        
        const postsList = document.getElementById('posts-list');
        postsList.innerHTML = '';
        
        if (data.posts && data.posts.length > 0) {
          data.posts.forEach(post => {
            const div = document.createElement('div');
            div.className = 'post-item';
            
            const avatarInfo = post.metadata?.avatarName 
              ? `<strong>${post.metadata.avatarEmoji || ''} ${post.metadata.avatarName}</strong><br>` 
              : '';
            
            div.innerHTML = `
              ${avatarInfo}
              ${post.content}
              <div class="post-meta">
                Posted: ${new Date(post.createdAt).toLocaleString()} 
                ${post.tweetId ? `| <a href="https://x.com/user/status/${post.tweetId}" target="_blank">View on X</a>` : ''}
                ${post.metadata?.type ? `| Type: ${post.metadata.type}` : ''}
              </div>
            `;
            
            postsList.appendChild(div);
          });
        } else {
          postsList.innerHTML = '<div class="loading">No posts yet</div>';
        }
        
        document.getElementById('posts-loading').style.display = 'none';
        document.getElementById('posts-list').style.display = 'block';
      } catch (err) {
        showError('Failed to load posts: ' + err.message);
        document.getElementById('posts-loading').style.display = 'none';
      }
    }
    
    // Utility functions
    function showError(msg) {
      const el = document.getElementById('status-message');
      el.className = 'error';
      el.textContent = '‚ùå ' + msg;
      el.style.display = 'block';
      setTimeout(() => el.style.display = 'none', 5000);
    }
    
    function showSuccess(msg) {
      const el = document.getElementById('status-message');
      el.className = 'success';
      el.textContent = '‚úÖ ' + msg;
      el.style.display = 'block';
      setTimeout(() => el.style.display = 'none', 3000);
    }
    
    function showStatus(msg) {
      const el = document.getElementById('status-message');
      el.className = 'success';
      el.textContent = '‚è≥ ' + msg;
      el.style.display = 'block';
    }
    
    function clearStatus() {
      document.getElementById('status-message').style.display = 'none';
    }
    
    // Wait for admin bootstrap to be ready
    async function initPage() {
      // Wait for AdminAPI to be available
      if (!window.AdminAPI) {
        await new Promise(resolve => {
          window.addEventListener('admin:bootstrapReady', resolve, { once: true });
        });
      }
      
  await loadModels();
  await loadPersona();
  setupTelegramConfigHandlers();
  await loadTelegramConfig();
  loadPosts();
    }
    
    // Load data on page load
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initPage);
    } else {
      initPage();
    }
  </script>
        </div>
      </div>
    </main>

    <footer class="bg-white">
      <div class="max-w-7xl mx-auto py-4 px-4 sm:px-6 lg:px-8">
        <p class="text-center text-sm text-gray-500">
          RATi Swarm Admin Panel ¬© 2024
        </p>
      </div>
    </footer>
  </div>
  <script type="module" src="/js/admin/admin-bootstrap.js"></script>
</body>
</html>
